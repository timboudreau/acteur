# A Dirt-Simple Acteur Application

One of the design goals of Acteur is simplicity of writing applications.  Below is
a minimal hello-world application:

```java
package example.acteur;

import com.google.inject.Inject;
import com.mastfrog.acteur.annotations.HttpCall;
import static com.mastfrog.acteur.headers.Headers.CONTENT_TYPE;
import static com.mastfrog.acteur.headers.Method.GET;
import com.mastfrog.acteur.preconditions.Methods;
import com.mastfrog.acteur.preconditions.Path;
import com.mastfrog.acteur.server.ServerBuilder;
import static com.mastfrog.mime.MimeType.PLAIN_TEXT_UTF_8;
import java.io.IOException;

@HttpCall
@Path("/hello")
@Methods(GET)
public final class HelloWorld extends Acteur {

    @Inject
    HelloWorld(HttpEvent evt) {
        add(CONTENT_TYPE, PLAIN_TEXT_UTF_8); // set the content-type header
        ok("Hello, person at " + evt.remoteAddress() + "\n"); // send our response
    }

    public static void main(String[] args) throws IOException {
        new ServerBuilder().build().start(8080);
    }
}
```

You can simply run this code, and then to test it, in a terminal, run

```sh
curl -i http://localhost:8080/hello
```

There are actually *three* `Acteur`s in the chain for a call to `/hello`, specified
by annotations - `@Path` says to the framework *insert a path-matching acteur
matching on `/hello` before this one*, and `@Methods(GET)` says *insert an
HTTP-method-matching Acteur ahead of this one that rejects the request if the HTTP
verb is not `GET`*.

The `@HttpCall` annotation tells the framework "Create a chain ending in this Acteur" - it
is the typical way you register a URL path and method.  It also causes some Java sources
and metadata files to be generated by an annotation processor, which allows `ServerBuilder`
to magically find everything it needs to 

The framework also has `@Precursors(Class<? extends Acteur>...)` and `@Concluders(Class<? extends Acteur>...)`
you can use to declaritively specify additional acteurs that precede or follow an `Acteur`
that has the `HttpCall` annotation.

## Adding Cache Header Handling

Any good web API should do a proper job of handling HTTP cache headers, so that a caller
can do vastly less work on both sides of the wire if the caller already has the same data
that would be returned.

The `ETag` header is supported by all modern browsers, and is simply an opaque string (often
a hash of the content that would be returned) which a browser having a cached copy of the
content from a past request simply sends back to the server in the `If-None-Match` header.

We will write one `Acteur` to the chain to set the `ETag` header, and *use* one built-into-the-framework
`Acteur`, `CheckIfNoneMatchHeader`, to short-circuit further work and send a `304 Not Modified` response.

So we will add a `@Precursors` annotation that spells out what is now in the chain:

```java
package example.acteur;

import com.google.inject.Inject;
import com.mastfrog.acteur.HelloWorld.HelloETagGenerator;
import com.mastfrog.acteur.annotations.HttpCall;
import com.mastfrog.acteur.annotations.Precursors;
import com.mastfrog.acteur.header.entities.CacheControl;
import static com.mastfrog.acteur.headers.Headers.CACHE_CONTROL;
import static com.mastfrog.acteur.headers.Headers.CONTENT_TYPE;
import static com.mastfrog.acteur.headers.Headers.ETAG;
import static com.mastfrog.acteur.headers.Method.GET;
import com.mastfrog.acteur.preconditions.Methods;
import com.mastfrog.acteur.preconditions.Path;
import com.mastfrog.acteur.server.ServerBuilder;
import static com.mastfrog.mime.MimeType.PLAIN_TEXT_UTF_8;
import java.io.IOException;
import java.net.InetSocketAddress;

@HttpCall(order = Integer.MIN_VALUE)
@Path("/hello")
@Methods(GET)
@Precursors({HelloETagGenerator.class, CheckIfNoneMatchHeader.class})
public final class HelloWorld extends Acteur {

    @Inject
    HelloWorld(InetSocketAddress addr) {
        add(CONTENT_TYPE, PLAIN_TEXT_UTF_8); // set the content-type header
        add(CACHE_CONTROL, CacheControl.PUBLIC_MUST_REVALIDATE_MAX_AGE_1_DAY);
        ok("Hello, person at " + addr.getHostString() + "\n");
    }

    public static void main(String[] args) throws IOException {
        new ServerBuilder().build().start(8080);
    }

    static class HelloETagGenerator extends Acteur {

        @Inject
        HelloETagGenerator(InetSocketAddress addr) {
            add(ETAG, Integer.toHexString(addr.getHostString().hashCode()));
            next();
        }
    }
}
```

## Handling URL Parameters

To personalize it a bit more, let's require that a name string be passed as the
URL parameter `name`.

We can add an acteur that will reject requests sans a `name` parameter just by adding
an annotation (which adds an acteur to the chain under-the-hood), by adding
`@RequireAtLeastOneUrlParameterFrom("name")` to our class.

And we will ask for the `HttpEvent` - the thing representing the HTTP request
as an argument to both our etag and response message computation, so we can get
hold of the URL parameter (which we never have to worry about being null, since
that gets checked before any of our code is called).

```java
@RequireAtLeastOneUrlParameterFrom("name")
public final class HelloWorld extends Acteur {

    @Inject
    HelloWorld(InetSocketAddress addr, HttpEvent evt) {
        add(CONTENT_TYPE, PLAIN_TEXT_UTF_8); // set the Content-Type header
        // and the Cache-Control header so the browser knows how long to keep it
        add(CACHE_CONTROL, CacheControl.PUBLIC_MUST_REVALIDATE_MAX_AGE_1_DAY);
        ok("Hello, " + evt.urlParameter("name") + " at " + addr.getHostString() + "\n");
    }

    public static void main(String[] args) throws IOException {
        new ServerBuilder().build().start(8080);
    }

    static class HelloETagGenerator extends Acteur {

        @Inject
        HelloETagGenerator(InetSocketAddress addr, HttpEvent evt) {
            add(ETAG, Integer.toHexString(addr.getHostString().hashCode()) + evt.urlParameter("name").hashCode());
            next();
        }
    }
}
```

# Conclusion

Hopefully that gives some of the flavor of the Acteur framework.  The 
subsequent chapters will go into more detail on everyday work with Acteur.
